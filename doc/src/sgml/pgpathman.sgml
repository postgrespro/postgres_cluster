<sect1 id="pg-pathman">
  <title>pg_pathman</title>
  <para>
    The <literal>pg_pathman</literal> module provides optimized
    partitioning mechanism and functions to manage partitions.
  </para>
  <para>
    The extension is compatible with &productname; 9.5, 9.6.
  </para>
  <sect2 id="pg-pathman-overview">
    <title>Overview</title>
    <para>
      <emphasis role="strong">Partitioning</emphasis> means splitting
      one large table into smaller pieces. Each row in such table is
      moved to a single partition according to the partitioning key.
      PostgreSQL supports partitioning via table inheritance: each
      partition must be created as a child table with CHECK CONSTRAINT.
      For example:
    </para>
    <programlisting>
CREATE TABLE test (id SERIAL PRIMARY KEY, title TEXT);
CREATE TABLE test_1 (CHECK ( id &gt;= 100 AND id &lt; 200 )) INHERITS (test);
CREATE TABLE test_2 (CHECK ( id &gt;= 200 AND id &lt; 300 )) INHERITS (test);
</programlisting>
    <para>
      Despite the flexibility, this approach forces the planner to
      perform an exhaustive search and to check constraints on each
      partition to determine whether it should be present in the plan or
      not. Large amount of partitions may result in significant planning
      overhead.
    </para>
    <para>
      The <literal>pg_pathman</literal> module features partition
      managing functions and optimized planning mechanism which utilizes
      knowledge of the partitions' structure. It stores partitioning
      configuration in the <literal>pathman_config</literal> table; each
      row contains a single entry for a partitioned table (relation
      name, partitioning column and its type). During the initialization
      stage the <literal>pg_pathman</literal> module caches some
      information about child partitions in the shared memory, which is
      used later for plan construction. Before a SELECT query is
      executed, <literal>pg_pathman</literal> traverses the condition
      tree in search of expressions like:
    </para>
    <programlisting>
VARIABLE OP CONST
</programlisting>
    <para>
      where <literal>VARIABLE</literal> is a partitioning key,
      <literal>OP</literal> is a comparison operator (supported
      operators are =, &lt;, &lt;=, &gt;, &gt;=),
      <literal>CONST</literal> is a scalar value. For example:
    </para>
    <programlisting>
WHERE id = 150
</programlisting>
    <para>
      Based on the partitioning type and condition's operator,
      <literal>pg_pathman</literal> searches for the corresponding
      partitions and builds the plan. Currently
      <literal>pg_pathman</literal> supports two partitioning schemes:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <emphasis role="strong">RANGE</emphasis> - maps rows to
          partitions using partitioning key ranges assigned to each
          partition. Optimization is achieved by using the binary search
          algorithm;
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">HASH</emphasis> - maps rows to
          partitions using a generic hash function.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      More interesting features are yet to come. Stay tuned!
    </para>
  </sect2>
  <sect2 id="roadmap">
    <title>Roadmap</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          Implement LIST partitioning scheme;
        </para>
      </listitem>
      <listitem>
        <para>
          Optimize hash join (both tables are partitioned by join key).
        </para>
      </listitem>
    </itemizedlist>
  </sect2>
  <sect2 id="installation-guide">
    <title>Installation guide</title>
    <para>
      To install <literal>pg_pathman</literal>, execute this in the
      module's directory:
    </para>
    <programlisting>
make install USE_PGXS=1
</programlisting>
    <para>
      Modify the
      <emphasis role="strong"><literal>shared_preload_libraries</literal></emphasis>
      parameter in <literal>postgresql.conf</literal> as following:
    </para>
    <programlisting>
shared_preload_libraries = 'pg_pathman'
</programlisting>
    <para>
      It is essential to restart the &productname; instance. After that,
      execute the following query in psql:
    </para>
    <programlisting>
CREATE EXTENSION pg_pathman;
</programlisting>
    <para>
      Done! Now it's time to setup your partitioning schemes.
    </para>
    <blockquote>
      <para>
        <emphasis role="strong">Important:</emphasis> Don't forget to
        set the <literal>PG_CONFIG</literal> variable in case you want
        to test <literal>pg_pathman</literal> on a custom build of
        PostgreSQL. Read more
        <ulink url="https://wiki.postgresql.org/wiki/Building_and_Installing_PostgreSQL_Extension_Modules">here</ulink>.
      </para>
    </blockquote>
  </sect2>
  <sect2 id="pg-pathman-how-to-update">
    <title>How to update</title>
    <para>
      In order to update pg_pathman:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          Install the latest _stable_ release of pg_pathman.
        </para>
      </listitem>
      <listitem>
        <para>
          Restart your PostgreSQL cluster.
        </para>
      </listitem>
      <listitem>
        <para>
          Execute the following queries:
        </para>
        <programlisting>
          /* replace X.Y with the version number, e.g. 1.3 */
          ALTER EXTENSION pg_pathman UPDATE TO "X.Y";
          SET pg_pathman.enable = t;
        </programlisting>
      </listitem>
    </itemizedlist>
  </sect2>
  <sect2 id="available-functions">
    <title>Available functions</title>
    <sect3 id="partition-creation">
      <title>Partition creation</title>
      <programlisting>
create_hash_partitions(relation         REGCLASS,
                       attribute        TEXT,
                       partitions_count INTEGER,
                       partition_data   BOOLEAN DEFAULT TRUE,
                       partition_names  TEXT[] DEFAULT NULL,
                       tablespaces      TEXT[] DEFAULT NULL)
</programlisting>
      <para>
        Performs HASH partitioning for <literal>relation</literal> by
        integer key <literal>attribute</literal>. The
        <literal>partitions_count</literal> parameter specifies the
        number of partitions to create; it cannot be changed afterwards.
        If <literal>partition_data</literal> is <literal>true</literal>
        then all the data will be automatically copied from the parent
        table to partitions. Note that data migration may took a while
        to finish and the table will be locked until transaction
        commits. See <literal>partition_table_concurrently()</literal>
        for a lock-free way to migrate data. Partition creation callback
        is invoked for each partition if set beforehand
        (see <literal>set_init_callback()</literal>).
      </para>
      <programlisting>
create_range_partitions(relation       REGCLASS,
                        attribute      TEXT,
                        start_value    ANYELEMENT,
                        interval       ANYELEMENT,
                        count          INTEGER DEFAULT NULL
                        partition_data BOOLEAN DEFAULT TRUE)

create_range_partitions(relation       REGCLASS,
                        attribute      TEXT,
                        start_value    ANYELEMENT,
                        interval       INTERVAL,
                        count          INTEGER DEFAULT NULL,
                        partition_data BOOLEAN DEFAULT TRUE)
</programlisting>
      <para>
        Performs RANGE partitioning for <literal>relation</literal> by
        partitioning key <literal>attribute</literal>,
        <literal>start_value</literal> argument specifies initial value,
        <literal>p_interval</literal> sets the default range for auto
        created partitions or partitions created with
        <literal>append_range_partition()</literal> or
        <literal>prepend_range_partition()</literal>
        (if <literal>NULL</literal> then auto partition creation
        feature will not work), <literal>p_count</literal> is the
        number of premade partitions (if not set then
        <literal>pg_pathman</literal> tries to determine it based
        on attribute values). Partition creation callback is invoked
        for each partition if set beforehand.
      </para>
      <programlisting>
create_partitions_from_range(relation       REGCLASS,
                             attribute      TEXT,
                             start_value    ANYELEMENT,
                             end_value      ANYELEMENT,
                             interval       ANYELEMENT,
                             partition_data BOOLEAN DEFAULT TRUE)

create_partitions_from_range(relation       REGCLASS,
                             attribute      TEXT,
                             start_value    ANYELEMENT,
                             end_value      ANYELEMENT,
                             interval       INTERVAL,
                             partition_data BOOLEAN DEFAULT TRUE)
</programlisting>
      <para>
        Performs RANGE-partitioning from specified range for
        <literal>relation</literal> by partitioning key
        <literal>attribute</literal>. Partition creation callback is
        invoked for each partition if set beforehand.
      </para>
    </sect3>
    <sect3 id="data-migration">
      <title>Data migration</title>
      <programlisting>
partition_table_concurrently(relation REGCLASS)
</programlisting>
      <para>
        Starts a background worker to move data from parent table to
        partitions. The worker utilizes short transactions to copy small
        batches of data (up to 10K rows per transaction) and thus
        doesn't significantly interfere with user's activity.
      </para>
      <programlisting>
stop_concurrent_part_task(relation REGCLASS)
</programlisting>
      <para>
        Stops a background worker performing a concurrent partitioning
        task. Note: worker will exit after it finishes relocating a
        current batch.
      </para>
    </sect3>
    <sect3 id="pg-pathman-triggers">
      <title>Triggers</title>
      <programlisting>
create_hash_update_trigger(parent REGCLASS)
</programlisting>
      <para>
        Creates the trigger on UPDATE for HASH partitions. The UPDATE
        trigger isn't created by default because of the overhead. It's
        useful in cases when the key attribute might change.
      </para>
      <programlisting>
create_range_update_trigger(parent REGCLASS)
</programlisting>
      <para>
        Same as above, but for a RANGE-partitioned table.
      </para>
    </sect3>
    <sect3 id="post-creation-partition-management">
      <title>Post-creation partition management</title>
      <programlisting>      
replace_hash_partition(old_partition       REGCLASS,
                       new_partition       REGCLASS,
                       lock_parent         BOOL DEFAULT TRUE)
      </programlisting>
      <para>
        Replaces specified partition of HASH-partitioned table with another table.
        The <literal>lock_parent</literal> parameter will prevent any INSERT/UPDATE/ALTER TABLE
        queries to parent table.
      </para>

      <programlisting>
split_range_partition(partition      REGCLASS,
                      value          ANYELEMENT,
                      partition_name TEXT DEFAULT NULL)
</programlisting>
      <para>
        Split RANGE <literal>partition</literal> in two by
        <literal>value</literal>. Partition creation callback is invoked
        for a new partition if available.
      </para>
      <programlisting>
merge_range_partitions(partition1 REGCLASS, partition2 REGCLASS)
</programlisting>
      <para>
        Merge two adjacent RANGE partitions. First, data from
        <literal>partition2</literal> is copied to
        <literal>partition1</literal>, then
        <literal>partition2</literal> is removed.
      </para>
      <programlisting>
merge_range_partitions(partitions REGCLASS[])
      </programlisting>
      <para>
        Merge several adjacent RANGE partitions (partitions must be specified
        in ascending or descending order). All the data will be accumulated in
        the first partition.
      </para>      
      <programlisting>
append_range_partition(p_relation     REGCLASS,
                       partition_name TEXT DEFAULT NULL,
                       tablespace     TEXT DEFAULT NULL)
</programlisting>
      <para>
        Append new RANGE partition with
        <literal>pathman_config.range_interval</literal> as interval.
      </para>
      <programlisting>
prepend_range_partition(p_relation     REGCLASS,
                        partition_name TEXT DEFAULT NULL,
                        tablespace     TEXT DEFAULT NULL)
</programlisting>
      <para>
        Prepend new RANGE partition with
        <literal>pathman_config.range_interval</literal> as interval.
      </para>
      <programlisting>
add_range_partition(relation       REGCLASS,
                    start_value    ANYELEMENT,
                    end_value      ANYELEMENT,
                    partition_name TEXT DEFAULT NULL,
                    tablespace     TEXT DEFAULT NULL)
</programlisting>
      <para>
        Create new RANGE partition for <literal>relation</literal> with
        specified range bounds. If <literal>start_value</literal>
        or <literal>end_value</literal> are NULL then corresponding
        range bound will be infinite.
      </para>
      <programlisting>
drop_range_partition(partition TEXT, delete_data BOOLEAN DEFAULT TRUE)
</programlisting>
      <para>
        Drop RANGE partition and all of its data if
        <literal>delete_data</literal> is true.
      </para>
      <programlisting>
attach_range_partition(relation    REGCLASS,
                       partition   REGCLASS,
                       start_value ANYELEMENT,
                       end_value   ANYELEMENT)
</programlisting>
      <para>
        Attach partition to the existing RANGE-partitioned relation. The
        attached table must have exactly the same structure as the
        parent table, including the dropped columns. Partition creation
        callback is invoked if set (see
        <literal>pathman_config_params</literal>).
      </para>
      <programlisting>
detach_range_partition(partition REGCLASS)
</programlisting>
      <para>
        Detach partition from the existing RANGE-partitioned relation.
      </para>
      <programlisting>
disable_pathman_for(relation TEXT)
</programlisting>
      <para>
        Permanently disable <literal>pg_pathman</literal> partitioning
        mechanism for the specified parent table and remove the insert
        trigger if it exists. All partitions and data remain unchanged.
      </para>
      <programlisting>
drop_partitions(parent      REGCLASS,
                delete_data BOOLEAN DEFAULT FALSE)
</programlisting>
      <para>
        Drop partitions of the <literal>parent</literal> table (both
        foreign and local relations). If <literal>delete_data</literal>
        is <literal>false</literal>, the data is copied to the parent
        table first. Default is <literal>false</literal>.
      </para>
    </sect3>
    <sect3 id="additional-parameters">
      <title>Additional parameters</title>
      <programlisting>
        set_interval(relation REGCLASS, value ANYELEMENT)
      </programlisting>
      <para>
        Update RANGE partitioned table interval. Note that interval must not
        be negative and it must not be trivial, i.e. its value should be
        greater than zero for numeric types, at least 1 microsecond for
        <literal>TIMESTAMP</literal> and at least 1 day
        for <literal>DATE</literal>.
      </para>      
      <programlisting>
set_enable_parent(relation REGCLASS, value BOOLEAN)
</programlisting>
      <para>
        Include/exclude parent table into/from query plan. In original
        PostgreSQL planner parent table is always included into query
        plan even if it's empty which can lead to additional overhead.
        You can use <literal>disable_parent()</literal> if you are never
        going to use parent table as a storage. Default value depends on
        the <literal>partition_data</literal> parameter that was
        specified during initial partitioning in
        <literal>create_range_partitions()</literal> or
        <literal>create_partitions_from_range()</literal> functions. If
        the <literal>partition_data</literal> parameter was
        <literal>true</literal> then all data have already been migrated
        to partitions and parent table disabled. Otherwise it is
        enabled.
      </para>
      <programlisting>
set_auto(relation REGCLASS, value BOOLEAN)
</programlisting>
      <para>
        Enable/disable auto partition propagation (only for RANGE
        partitioning). It is enabled by default.
      </para>
      <programlisting>
set_init_callback(relation REGCLASS, callback REGPROC DEFAULT 0)
</programlisting>
      <para>
        Set partition creation callback to be invoked for each attached
        or created partition (both HASH and RANGE). The callback must
        have the following signature:
        <literal>part_init_callback(args JSONB) RETURNS VOID</literal>.
        Parameter <literal>arg</literal> consists of several fields
        whose presence depends on partitioning type:
      </para>
      <programlisting>
/* RANGE-partitioned table abc (child abc_4) */
{
    &quot;parent&quot;:    &quot;abc&quot;,
    &quot;parttype&quot;:  &quot;2&quot;,
    &quot;partition&quot;: &quot;abc_4&quot;,
    &quot;range_max&quot;: &quot;401&quot;,
    &quot;range_min&quot;: &quot;301&quot;
}

/* HASH-partitioned table abc (child abc_0) */
{
    &quot;parent&quot;:    &quot;abc&quot;,
    &quot;parttype&quot;:  &quot;1&quot;,
    &quot;partition&quot;: &quot;abc_0&quot;
}
      </programlisting>
      <programlisting>
set_spawn_using_bgw(relation REGCLASS, value BOOLEAN)
      </programlisting>
      <para>
        When INSERTing new data beyond the partitioning range,
        use SpawnPartitionsWorker to create new partitions in a
        separate transaction.
      </para>
    </sect3>
  </sect2>
  <sect2 id="views-and-tables">
    <title>Views and tables</title>
    <sect3 id="pathman-config-main-config-storage">
      <title><literal>pathman_config</literal> --- main config
      storage</title>
      <programlisting>
CREATE TABLE IF NOT EXISTS pathman_config (
    partrel         REGCLASS NOT NULL PRIMARY KEY,
    attname         TEXT NOT NULL,
    parttype        INTEGER NOT NULL,
    range_interval  TEXT);
</programlisting>
      <para>
        This table stores a list of partitioned tables.
      </para>
    </sect3>
    <sect3 id="pathman-config-params-optional-parameters">
      <title><literal>pathman_config_params</literal> --- optional
      parameters</title>
      <programlisting>
CREATE TABLE IF NOT EXISTS pathman_config_params (
    partrel        REGCLASS NOT NULL PRIMARY KEY,
    enable_parent  BOOLEAN NOT NULL DEFAULT TRUE,
    auto           BOOLEAN NOT NULL DEFAULT TRUE,
    init_callback  REGPROCEDURE NOT NULL DEFAULT 0,
    spawn_using_bgw BOOLEAN NOT NULL DEFAULT FALSE);
</programlisting>
      <para>
        This table stores optional parameters which override standard
        behavior.
      </para>
    </sect3>
    <sect3 id="pathman-concurrent-part-tasks-currently-running-partitioning-workers">
      <title><literal>pathman_concurrent_part_tasks</literal> ---
      currently running partitioning workers</title>
      <programlisting>
-- helper SRF function
CREATE OR REPLACE FUNCTION show_concurrent_part_tasks()
RETURNS TABLE (
    userid     REGROLE,
    pid        INT,
    dbid       OID,
    relid      REGCLASS,
    processed  INT,
    status     TEXT)
AS 'pg_pathman', 'show_concurrent_part_tasks_internal'
LANGUAGE C STRICT;

CREATE OR REPLACE VIEW pathman_concurrent_part_tasks
AS SELECT * FROM show_concurrent_part_tasks();
</programlisting>
      <para>
        This view lists all currently running concurrent partitioning
        tasks.
      </para>
    </sect3>
    <sect3 id="pathman-partition-list-list-of-all-existing-partitions">
      <title><literal>pathman_partition_list</literal> --- list of all
      existing partitions</title>
      <programlisting>
-- helper SRF function
CREATE OR REPLACE FUNCTION show_partition_list()
RETURNS TABLE (
    parent     REGCLASS,
    partition  REGCLASS,
    parttype   INT4,
    partattr   TEXT,
    range_min  TEXT,
    range_max  TEXT)
AS 'pg_pathman', 'show_partition_list_internal'
LANGUAGE C STRICT;

CREATE OR REPLACE VIEW pathman_partition_list
AS SELECT * FROM show_partition_list();
</programlisting>
      <para>
        This view lists all existing partitions, as well as their
        parents and range boundaries (NULL for HASH partitions).
      </para>
    </sect3>
  </sect2>
  <sect2 id="custom-plan-nodes">
    <title>Custom plan nodes</title>
    <para>
      <literal>pg_pathman</literal> provides a couple of
      <ulink url="https://wiki.postgresql.org/wiki/CustomScanAPI">custom
      plan nodes</ulink> which aim to reduce execution time, namely:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <literal>RuntimeAppend</literal> (overrides
          <literal>Append</literal> plan node)
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>RuntimeMergeAppend</literal> (overrides
          <literal>MergeAppend</literal> plan node)
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>PartitionFilter</literal> (drop-in replacement for
          INSERT triggers)
        </para>
      </listitem>
    </itemizedlist>
    <para>
      <literal>PartitionFilter</literal> acts as a <emphasis>proxy
      node</emphasis> for INSERT's child scan, which means it can
      redirect output tuples to the corresponding partition:
    </para>
    <programlisting>
EXPLAIN (COSTS OFF)
INSERT INTO partitioned_table
SELECT generate_series(1, 10), random();
               QUERY PLAN
-----------------------------------------
 Insert on partitioned_table
   -&gt;  Custom Scan (PartitionFilter)
         -&gt;  Subquery Scan on &quot;*SELECT*&quot;
               -&gt;  Result
(4 rows)
</programlisting>
    <para>
      <literal>RuntimeAppend</literal> and
      <literal>RuntimeMergeAppend</literal> have much in common: they
      come in handy in a case when WHERE condition takes form of:
    </para>
    <programlisting>
VARIABLE OP PARAM
</programlisting>
    <para>
      This kind of expressions can no longer be optimized at planning
      time since the parameter's value is not known until the execution
      stage takes place. The problem can be solved by embedding the
      <emphasis>WHERE condition analysis routine</emphasis> into the
      original <literal>Append</literal>'s code, thus making it pick
      only required scans out of a whole bunch of planned partition
      scans. This effectively boils down to creation of a custom node
      capable of performing such a check.
    </para>
    <para>
      There are at least several cases that demonstrate usefulness of
      these nodes:
    </para>
    <programlisting>
/* create table we're going to partition */
CREATE TABLE partitioned_table(id INT NOT NULL, payload REAL);

/* insert some data */
INSERT INTO partitioned_table
SELECT generate_series(1, 1000), random();

/* perform partitioning */
SELECT create_hash_partitions('partitioned_table', 'id', 100);

/* create ordinary table */
CREATE TABLE some_table AS SELECT generate_series(1, 100) AS VAL;
    </programlisting>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <emphasis role="strong"><literal>id = (select ... limit 1)</literal></emphasis>
          <programlisting>
plpgsql
EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM partitioned_table
WHERE id = (SELECT * FROM some_table LIMIT 1);
                                             QUERY PLAN
----------------------------------------------------------------------------------------------------
 Custom Scan (RuntimeAppend) (actual time=0.030..0.033 rows=1 loops=1)
   InitPlan 1 (returns $0)
     -&gt;  Limit (actual time=0.011..0.011 rows=1 loops=1)
           -&gt;  Seq Scan on some_table (actual time=0.010..0.010 rows=1 loops=1)
   -&gt;  Seq Scan on partitioned_table_70 partitioned_table (actual time=0.004..0.006 rows=1 loops=1)
         Filter: (id = $0)
         Rows Removed by Filter: 9
 Planning time: 1.131 ms
 Execution time: 0.075 ms
(9 rows)

/* disable RuntimeAppend node */
SET pg_pathman.enable_runtimeappend = f;

EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM partitioned_table
WHERE id = (SELECT * FROM some_table LIMIT 1);
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Append (actual time=0.196..0.274 rows=1 loops=1)
   InitPlan 1 (returns $0)
     -&gt;  Limit (actual time=0.005..0.005 rows=1 loops=1)
           -&gt;  Seq Scan on some_table (actual time=0.003..0.003 rows=1 loops=1)
   -&gt;  Seq Scan on partitioned_table_0 (actual time=0.014..0.014 rows=0 loops=1)
         Filter: (id = $0)
         Rows Removed by Filter: 6
   -&gt;  Seq Scan on partitioned_table_1 (actual time=0.003..0.003 rows=0 loops=1)
         Filter: (id = $0)
         Rows Removed by Filter: 5
         ... /* more plans follow */
 Planning time: 1.140 ms
 Execution time: 0.855 ms
(306 rows)
          </programlisting>
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong"><literal>id = ANY (select ...)</literal></emphasis>
          <programlisting>
plpgsql
EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM partitioned_table
WHERE id = any (SELECT * FROM some_table limit 4);
                                                QUERY PLAN
-----------------------------------------------------------------------------------------------------------
 Nested Loop (actual time=0.025..0.060 rows=4 loops=1)
   -&gt;  Limit (actual time=0.009..0.011 rows=4 loops=1)
         -&gt;  Seq Scan on some_table (actual time=0.008..0.010 rows=4 loops=1)
   -&gt;  Custom Scan (RuntimeAppend) (actual time=0.002..0.004 rows=1 loops=4)
         -&gt;  Seq Scan on partitioned_table_70 partitioned_table (actual time=0.001..0.001 rows=10 loops=1)
         -&gt;  Seq Scan on partitioned_table_26 partitioned_table (actual time=0.002..0.003 rows=9 loops=1)
         -&gt;  Seq Scan on partitioned_table_27 partitioned_table (actual time=0.001..0.002 rows=20 loops=1)
         -&gt;  Seq Scan on partitioned_table_63 partitioned_table (actual time=0.001..0.002 rows=9 loops=1)
 Planning time: 0.771 ms
 Execution time: 0.101 ms
(10 rows)

/* disable RuntimeAppend node */
SET pg_pathman.enable_runtimeappend = f;

EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM partitioned_table
WHERE id = any (SELECT * FROM some_table limit 4);
                                       QUERY PLAN
-----------------------------------------------------------------------------------------
 Nested Loop Semi Join (actual time=0.531..1.526 rows=4 loops=1)
   Join Filter: (partitioned_table.id = some_table.val)
   Rows Removed by Join Filter: 3990
   -&gt;  Append (actual time=0.190..0.470 rows=1000 loops=1)
         -&gt;  Seq Scan on partitioned_table (actual time=0.187..0.187 rows=0 loops=1)
         -&gt;  Seq Scan on partitioned_table_0 (actual time=0.002..0.004 rows=6 loops=1)
         -&gt;  Seq Scan on partitioned_table_1 (actual time=0.001..0.001 rows=5 loops=1)
         -&gt;  Seq Scan on partitioned_table_2 (actual time=0.002..0.004 rows=14 loops=1)
... /* 96 scans follow */
   -&gt;  Materialize (actual time=0.000..0.000 rows=4 loops=1000)
         -&gt;  Limit (actual time=0.005..0.006 rows=4 loops=1)
               -&gt;  Seq Scan on some_table (actual time=0.003..0.004 rows=4 loops=1)
 Planning time: 2.169 ms
 Execution time: 2.059 ms
(110 rows)
          </programlisting>
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong"><literal>NestLoop</literal> involving
            a partitioned table</emphasis>, which is omitted since it's
          occasionally shown above.
        </para>
          </listitem>
    </itemizedlist>
    <para>
      In case you're interested, you can read more about custom nodes at
      Alexander Korotkov's
      <ulink url="http://akorotkov.github.io/blog/2016/06/15/pg_pathman-runtime-append/">blog</ulink>.
    </para>
  </sect2>
  <sect2 id="examples">
    <title>Examples</title>
    <sect3 id="common-tips">
      <title>Common tips</title>
      <itemizedlist>
        <listitem>
          <para>
            You can easily add
            <emphasis role="strong"><emphasis>partition</emphasis></emphasis>
            column containing the names of the underlying partitions
            using the system attribute called
            <emphasis role="strong"><emphasis>tableoid</emphasis></emphasis>:
          </para>
          <programlisting>
            SELECT tableoid::regclass AS partition, * FROM partitioned_table;
          </programlisting>
        </listitem>
        <listitem>
          <para>
            Though indices on a parent table aren't particularly useful
            (since it's supposed to be empty), they act as prototypes
            for indices on partitions. For each index on the parent
            table, <literal>pg_pathman</literal> will create a similar
            index on every partition.
          </para>
        </listitem>
        <listitem>
          <para>
            All running concurrent partitioning tasks can be listed
            using the <literal>pathman_concurrent_part_tasks</literal>
            view:
          </para>
          <programlisting>
            SELECT * FROM pathman_concurrent_part_tasks;
            userid  | pid  | dbid  | relid | processed | status  
            --------+------+-------+-------+-----------+---------
            dmitry  | 7367 | 16384 | test  |    472000 | working
            (1 row)
          </programlisting>
        </listitem>
        <listitem>
          <para>
            <literal>pathman_partition_list</literal> in conjunction
            with <literal>drop_range_partition()</literal> can be used
            to drop RANGE partitions in a more flexible way compared to
            good old <literal>DROP TABLE</literal>:
          </para>
          <programlisting>
            SELECT drop_range_partition(partition, false) /* move data to parent */
            FROM pathman_partition_list
            WHERE parent = 'part_test'::regclass AND range_min::int &lt; 500;
            NOTICE:  1 rows copied from part_test_11
            NOTICE:  100 rows copied from part_test_1
            NOTICE:  100 rows copied from part_test_2
            drop_range_partition 
            ----------------------
            dummy_test_11
            dummy_test_1
            dummy_test_2
            (3 rows)
          </programlisting>
        </listitem>
      </itemizedlist>
    </sect3>
    <sect3 id="hash-partitioning">
      <title>HASH partitioning</title>
      <para>
        Consider an example of HASH partitioning. First create a table
        with some integer column:
      </para>
      <programlisting>
        CREATE TABLE items (
        id       SERIAL PRIMARY KEY,
        name     TEXT,
        code     BIGINT);

        INSERT INTO items (id, name, code)
        SELECT g, md5(g::text), random() * 100000
        FROM generate_series(1, 100000) as g;
      </programlisting>
      <para>
        Now run the <literal>create_hash_partitions()</literal> function
        with appropriate arguments:
      </para>
      <programlisting>
        SELECT create_hash_partitions('items', 'id', 100);
      </programlisting>
      <para>
        This will create new partitions and move the data from parent to
        partitions.
      </para>
      <para>
        Here's an example of the query performing filtering by
        partitioning key:
      </para>
      <programlisting>
        SELECT * FROM items WHERE id = 1234;
        id  |               name               | code
        ------+----------------------------------+------
        1234 | 81dc9bdb52d04dc20036dbd8313ed055 | 1855
        (1 row)

        EXPLAIN SELECT * FROM items WHERE id = 1234;
        QUERY PLAN
        ------------------------------------------------------------------------------------
        Append  (cost=0.28..8.29 rows=0 width=0)
        -&gt;  Index Scan using items_34_pkey on items_34  (cost=0.28..8.29 rows=0 width=0)
        Index Cond: (id = 1234)
      </programlisting>
      <para>
        Notice that the <literal>Append</literal> node contains only one
        child scan which corresponds to the WHERE clause.
      </para>
      <blockquote>
        <para>
          <emphasis role="strong">Important:</emphasis> pay attention to
          the fact that <literal>pg_pathman</literal> excludes the
          parent table from the query plan.
        </para>
      </blockquote>
      <para>
        To access parent table use ONLY modifier:
      </para>
      <programlisting>
        EXPLAIN SELECT * FROM ONLY items;
        QUERY PLAN
        ------------------------------------------------------
        Seq Scan on items  (cost=0.00..0.00 rows=1 width=45)
      </programlisting>
    </sect3>
    <sect3 id="range-partitioning">
      <title>RANGE partitioning</title>
      <para>
        Consider an example of RANGE partitioning. Let's create a table
        containing some dummy logs:
      </para>
      <programlisting>
        CREATE TABLE journal (
        id      SERIAL,
        dt      TIMESTAMP NOT NULL,
        level   INTEGER,
        msg     TEXT);

        -- similar index will also be created for each partition
        CREATE INDEX ON journal(dt);

        -- generate some data
        INSERT INTO journal (dt, level, msg)
        SELECT g, random() * 6, md5(g::text)
        FROM generate_series('2015-01-01'::date, '2015-12-31'::date, '1 minute') as g;
      </programlisting>
      <para>
        Run the <literal>create_range_partitions()</literal> function to
        create partitions so that each partition would contain the data
        for one day:
      </para>
      <programlisting>
        SELECT create_range_partitions('journal', 'dt', '2015-01-01'::date, '1 day'::interval);
      </programlisting>
      <para>
        It will create 365 partitions and move the data from parent to
        partitions.
      </para>
      <para>
        New partitions are appended automaticaly by insert trigger, but
        it can be done manually with the following functions:
      </para>
      <programlisting>
        -- add new partition with specified range
        SELECT add_range_partition('journal', '2016-01-01'::date, '2016-01-07'::date);

        -- append new partition with default range
        SELECT append_range_partition('journal');
      </programlisting>
      <para>
        The first one creates a partition with specified range. The
        second one creates a partition with default interval and appends
        it to the partition list. It is also possible to attach an
        existing table as partition. For example, we may want to attach
        an archive table (or even foreign table from another server) for
        some outdated data:
      </para>
      <programlisting>
        CREATE FOREIGN TABLE journal_archive (
        id      INTEGER NOT NULL,
        dt      TIMESTAMP NOT NULL,
        level   INTEGER,
        msg     TEXT)
        SERVER archive_server;

        SELECT attach_range_partition('journal', 'journal_archive', '2014-01-01'::date, '2015-01-01'::date);
      </programlisting>
      <blockquote>
        <para>
          <emphasis role="strong">Important:</emphasis> the definition
          of the attached table must match the one of the existing
          partitioned table, including the dropped columns.
        </para>
      </blockquote>
      <para>
        To merge to adjacent partitions, use the
        <literal>merge_range_partitions()</literal> function:
      </para>
      <programlisting>
        SELECT merge_range_partitions('journal_archive', 'journal_1');
      </programlisting>
      <para>
        To split partition by value, use the
        <literal>split_range_partition()</literal> function:
      </para>
      <programlisting>
        SELECT split_range_partition('journal_366', '2016-01-03'::date);
      </programlisting>
      <para>
        To detach partition, use the
        <literal>detach_range_partition()</literal> function:
      </para>
      <programlisting>
        SELECT detach_range_partition('journal_archive');
      </programlisting>
      <para>
        Here's an example of the query performing filtering by
        partitioning key:
      </para>
      <programlisting>
        SELECT * FROM journal WHERE dt &gt;= '2015-06-01' AND dt &lt; '2015-06-03';
        id      |         dt          | level |               msg
        --------+---------------------+-------+----------------------------------
        217441  | 2015-06-01 00:00:00 |     2 | 15053892d993ce19f580a128f87e3dbf
        217442  | 2015-06-01 00:01:00 |     1 | 3a7c46f18a952d62ce5418ac2056010c
        217443  | 2015-06-01 00:02:00 |     0 | 92c8de8f82faf0b139a3d99f2792311d
        ...
        (2880 rows)

        EXPLAIN SELECT * FROM journal WHERE dt &gt;= '2015-06-01' AND dt &lt; '2015-06-03';
        QUERY PLAN
        ------------------------------------------------------------------
        Append  (cost=0.00..58.80 rows=0 width=0)
        -&gt;  Seq Scan on journal_152  (cost=0.00..29.40 rows=0 width=0)
        -&gt;  Seq Scan on journal_153  (cost=0.00..29.40 rows=0 width=0)
        (3 rows)
      </programlisting>
    </sect3>
    <sect3 id="disabling-pg-pathman">
      <title>Disabling <literal>pg_pathman</literal></title>
      <para>
        There are several user-accessible
        <ulink url="https://www.postgresql.org/docs/9.5/static/config-setting.html">GUC</ulink>
        variables designed to toggle the whole module or specific custom
        nodes on and off:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>pg_pathman.enable</literal> --- disable (or enable)
            <literal>pg_pathman</literal> completely
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>pg_pathman.enable_runtimeappend</literal> ---
            toggle <literal>RuntimeAppend</literal> custom node on
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>pg_pathman.enable_runtimemergeappend</literal> ---
            toggle <literal>RuntimeMergeAppend</literal> custom node on
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>pg_pathman.enable_partitionfilter</literal> ---
            toggle <literal>PartitionFilter</literal> custom node on
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>pg_pathman.enable_auto_partition</literal> ---
            toggle automatic partition creation on(per session)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>pg_pathman.insert_into_fdw</literal> --- allow
            INSERTs into various FDWs
            <literal>(disabled | postgres | any_fdw)</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>pg_pathman.override_copy</literal> --- toggle COPY
            statement hooking on
          </para>
        </listitem>
      </itemizedlist>
      <para>
        To <emphasis role="strong">permanently</emphasis> disable
        <literal>pg_pathman</literal> for some previously partitioned
        table, use the <literal>disable_pathman_for()</literal>
        function:
      </para>
      <programlisting>
        SELECT disable_pathman_for('range_rel');
      </programlisting>
      <para>
        All sections and data will remain unchanged and will be handled
        by the standard PostgreSQL inheritance mechanism.
      </para>
    </sect3>
  </sect2>
  <sect2 id="feedback">
    <title>Feedback</title>
    <para>
      Do not hesitate to post your issues, questions and new ideas at
      the
      <ulink url="https://github.com/postgrespro/pg_pathman/issues">issues</ulink>
      page.
    </para>
  </sect2>
  <sect2 id="authors">
    <title>Authors</title>
    <literallayout>Ildar Musin <email>i.musin@postgrespro.ru</email> Postgres Professional Ltd., Russia
      Alexander Korotkov <email>a.korotkov@postgrespro.ru</email> Postgres Professional Ltd., Russia
      Dmitry Ivanov <email>d.ivanov@postgrespro.ru</email> Postgres Professional Ltd., Russia</literallayout>
  </sect2>
</sect1>
